/*
FIFO:
    /*AUTOSVA
    fifo_transaction: in -IN> out
                        in_val = in_val
                        in_ready = in_rdy
    [SIZE-1:0]         in_data = in_data
    [INFLIGHT_IDX-1:0] in_transid = buffer_head_reg
                        out_val = out_val
                        out_ready = out_rdy
    [SIZE-1:0]         out_data = out_data
    [INFLIGHT_IDX-1:0] out_transid = buffer_tail_reg
    
    Chosen AUTOSVA Syntax:
        - in as Input to out
            - ...

    Grouped Signal Definitions:
        in_hsk = in_val && in_rdy;
        in_transid = fifo.buffer_head_reg;    
        fifo_transid_set = in_hsk && in_transid == symb_in_transid;
        
        out_hsk = out_val && out_rdy;
        out_transid = fifo.buffer_tail_reg;
        fifo_transid_response = out_hsk && out_transid == symb_in_transid;       
        
        reg [3:0] fifo_transid_sampled;

        always_ff @(posedge clk) begin
            if(!rst_n) begin
                fifo_transid_sampled <= '0;
            end else if (fifo_transid_set || fifo_transid_response ) begin
                fifo_transid_sampled <= fifo_transid_sampled + fifo_transid_set - fifo_transid_response;
            end
        end

        reg [SIZE-1:0] fifo_transid_data_model;

        always_ff @(posedge clk) begin
            if(!rst_n) begin
                fifo_transid_data_model <= '0;
            end else if (fifo_transid_set) begin
                fifo_transid_data_model <= in_data;
            end
        end

    Symbolics: Unconstrained, verification tool explores all possible values  

	ASSERT_INPUTS:
	- Doesn't seem like it is going to 1 considering _bind.svh. Therefore, all signals dependent on this condition are constrained using assume, not asserted

	ASSERT_INPUTS Assumptions:
    - am__fifo_fairness:                        if out_val is set, constrain out_rdy to be eventually set 
    - am__fifo_transid_sample_no_overflow:      constrain fifo_transid_sampled != '1 OR fifo_transid_set is NOT set

    ASSERT_INPUTS Assertions:
    - ... same but with assert

    ASSERT_INPUTS Covers:
    - co__fifo_transid_sampled:                 flag simulation as covered if fifo_transid_sampled has set bit

    Autogenerated Assumptions:
    - am__symb_in_transid_stable:               constrain symb_in_transid to be stable
    
    Autogenerated Assertions:
    - as__fifo_transid_hsk_or_drop:             if in_val is set, eventually in_val needs to be NOT set AND in_rdy needs to be set
    - as__fifo_transid_eventual_response:       if fifo_transid_sampled has set bit, eventually out_val needs to be set AND (out_transid == symb_in_transid)
    - as__fifo_transid_was_a_request:           if fifo_transid_response is set, then fifo_transid_set is set OR fifo_transid_sampled has set bit
    - as__fifo_transid_data_unique:             if fifo_transid_sampled has set bit, fifo_transid_set needs to be NOT set
    - as__fifo_transid_data_integrity:          if fifo_transid_sampled has set bit AND fifo_transid_response is set, out_data needs to be out_data == fifo_transid_data_model

    Autogenerated Covers:
*/
module fifo_prop
#(
		parameter ASSERT_INPUTS = 0,
		parameter INFLIGHT_IDX = 2,
		parameter SIZE = 4
)
(		// Clock + Reset
		input  wire                          clk,
		input  wire                          rst_n,
		input  wire                          in_val,
		input  wire                          in_rdy, //output
		input  wire [SIZE-1:0]               in_data,
		
		input  wire                          out_val, //output
		input  wire                          out_rdy,
		input  wire [SIZE-1:0]               out_data //output
	);

    //==============================================================================
    // Local Parameters
    //==============================================================================
    localparam INFLIGHT = 2**INFLIGHT_IDX;

    genvar j;
    default clocking cb @(posedge clk);
    endclocking
    default disable iff (!rst_n);

    // Re-defined wires 
    wire [INFLIGHT_IDX-1:0] in_transid;
    wire [INFLIGHT_IDX-1:0] out_transid;

    // Symbolics and Handshake signals
    wire [INFLIGHT_IDX-1:0] symb_in_transid;
    am__symb_in_transid_stable: assume property($stable(symb_in_transid));
    wire out_hsk = out_val && out_rdy;
    wire in_hsk = in_val && in_rdy;

    //==============================================================================
    // Modeling
    //==============================================================================

    // Modeling incoming request for fifo
    if (ASSERT_INPUTS) begin
        as__fifo_fairness: assert property (out_val |-> s_eventually(out_rdy));
    end else begin
        am__fifo_fairness: assume property (out_val |-> s_eventually(out_rdy));
    end

    // Generate sampling signals and model
    reg [3:0] fifo_transid_sampled;
    wire fifo_transid_set = in_hsk && in_transid == symb_in_transid;
    wire fifo_transid_response = out_hsk && out_transid == symb_in_transid;

    always_ff @(posedge clk) begin
        if(!rst_n) begin
            fifo_transid_sampled <= '0;
        end else if (fifo_transid_set || fifo_transid_response ) begin
            fifo_transid_sampled <= fifo_transid_sampled + fifo_transid_set - fifo_transid_response;
        end
    end

    co__fifo_transid_sampled: cover property (|fifo_transid_sampled);
    if (ASSERT_INPUTS) begin
        as__fifo_transid_sample_no_overflow: assert property (fifo_transid_sampled != '1 || !fifo_transid_set);
    end else begin
        am__fifo_transid_sample_no_overflow: assume property (fifo_transid_sampled != '1 || !fifo_transid_set);
    end


    // Assert that if valid eventually ready or dropped valid
    as__fifo_transid_hsk_or_drop: assert property (in_val |-> s_eventually(!in_val || in_rdy));
    // Assert that every request has a response and that every reponse has a request
    as__fifo_transid_eventual_response: assert property (|fifo_transid_sampled |-> s_eventually(out_val && (out_transid == symb_in_transid) ));
    as__fifo_transid_was_a_request: assert property (fifo_transid_response |-> fifo_transid_set || fifo_transid_sampled);


    // Modeling data integrity for fifo_transid
    reg [SIZE-1:0] fifo_transid_data_model;
    always_ff @(posedge clk) begin
        if(!rst_n) begin
            fifo_transid_data_model <= '0;
        end else if (fifo_transid_set) begin
            fifo_transid_data_model <= in_data;
        end
    end

    as__fifo_transid_data_unique: assert property (|fifo_transid_sampled |-> !fifo_transid_set);
    as__fifo_transid_data_integrity: assert property (|fifo_transid_sampled && fifo_transid_response |-> (out_data == fifo_transid_data_model));

    assign out_transid = fifo.buffer_tail_reg;
    assign in_transid = fifo.buffer_head_reg;

endmodule
