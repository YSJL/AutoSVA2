/*
PTW:
    /*AUTOSVA
    ptw_req: ptw_req --OUT> ptw_res
    ptw_req_val = req_port_o.data_req
    ptw_req_rdy = req_port_i.data_gnt
    ptw_res_val = req_port_i.data_rvalid

    itlb_iface: itlb --IN> itlb_update
    itlb_iface_active = ptw_active_o
    itlb_val = enable_translation_i & itlb_access_i & ~itlb_hit_i & ~dtlb_access_i & !flush_i
    itlb_rdy = !ptw_active_o
    [riscv::VLEN-1:0] itlb_stable = itlb_vaddr_i
    [riscv::VLEN-1:0] itlb_data = itlb_vaddr_i
    itlb_update_val = itlb_update_o.valid || walking_instr_o && (ptw_access_exception_o || ptw_error_o || ptw_active_o && flush_i)
    [riscv::VLEN-1:0] itlb_update_data = update_vaddr_o

    dtlb_iface: dtlb --IN> dtlb_update
    dtlb_iface_active = ptw_active_o
    dtlb_val = en_ld_st_translation_i & dtlb_access_i & ~dtlb_hit_i & !flush_i
    dtlb_rdy = !ptw_active_o
    [riscv::VLEN-1:0] dtlb_stable = dtlb_vaddr_i
    [riscv::VLEN-1:0] dtlb_data = dtlb_vaddr_i
    dtlb_update_val = dtlb_update_o.valid || !walking_instr_o && (ptw_access_exception_o || ptw_error_o || ptw_active_o && flush_i)
    [riscv::VLEN-1:0] dtlb_update_data = update_vaddr_o
    
    Chosen AUTOSVA Syntax:
    - ptw_res as Output to ptw_req
        - ...
    - itlb as Input to itlb_update
		- ...
    - dtlb as Input to dtlb_update
        - ...

	Grouped Signal Definitions:
		itlb_data = itlb_vaddr_i;
		dtlb_data = dtlb_vaddr_i;
		itlb_iface_active = ptw_active_o;
		dtlb_iface_active = ptw_active_o;

		itlb_stable = itlb_vaddr_i;
		dtlb_stable = dtlb_vaddr_i;

		itlb_update_data = update_vaddr_o;
		dtlb_update_data = update_vaddr_o;

		itlb_update_val = itlb_update_o.valid || walking_instr_o && (ptw_access_exception_o || ptw_error_o || ptw_active_o && flush_i);
		itlb_update_hsk = itlb_update_val;					//Signal Generated by AUTOSVA
		itlb_iface_transid_response = itlb_update_hsk;		//Signal Generated by AUTOSVA

		itlb_val = enable_translation_i & itlb_access_i & ~itlb_hit_i & ~dtlb_access_i & !flush_i;
		itlb_rdy = !ptw_active_o;
		itlb_hsk = itlb_val && itlb_rdy;					//Signal Generated by AUTOSVA
		itlb_iface_transid_set = itlb_hsk;					//Signal Generated by AUTOSVA

		dtlb_update_val = dtlb_update_o.valid || !walking_instr_o && (ptw_access_exception_o || ptw_error_o || ptw_active_o && flush_i);
		dtlb_update_hsk = dtlb_update_val;					//Signal Generated by AUTOSVA
		dtlb_iface_transid_response = dtlb_update_hsk;		//Signal Generated by AUTOSVA

		dtlb_val = en_ld_st_translation_i & dtlb_access_i & ~dtlb_hit_i & !flush_i;
		dtlb_rdy = !ptw_active_o;
		dtlb_hsk = dtlb_val && dtlb_rdy;					//Signal Generated by AUTOSVA
		dtlb_iface_transid_set = dtlb_hsk;					//Signal Generated by AUTOSVA

		ptw_res_val = req_port_i.data_rvalid;
		ptw_res_hsk = ptw_res_val;							//Signal Generated by AUTOSVA

		ptw_req_val = req_port_o.data_req;
		ptw_req_rdy = req_port_i.data_gnt;
		ptw_req_hsk = ptw_req_val && ptw_req_rdy;			//Signal Generated by AUTOSVA

		reg [3:0] itlb_iface_transid_sampled;				//Signal Generated by AUTOSVA
		reg [3:0] dtlb_iface_transid_sampled;				//Signal Generated by AUTOSVA

		always_ff @(posedge clk_i) begin
			if(!rst_ni) begin
				itlb_iface_transid_sampled <= '0;
			end else if (itlb_iface_transid_set || itlb_iface_transid_response ) begin
				itlb_iface_transid_sampled <= itlb_iface_transid_sampled + itlb_iface_transid_set - itlb_iface_transid_response;
			end
		end
		always_ff @(posedge clk_i) begin
			if(!rst_ni) begin
				dtlb_iface_transid_sampled <= '0;
			end else if (dtlb_iface_transid_set || dtlb_iface_transid_response ) begin
				dtlb_iface_transid_sampled <= dtlb_iface_transid_sampled + dtlb_iface_transid_set - dtlb_iface_transid_response;
			end
		end

		reg [1-1:0] ptw_req_outstanding_req_r;				//Signal Generated by AUTOSVA

		always_ff @(posedge clk_i) begin
			if(!rst_ni) begin
				ptw_req_outstanding_req_r <= '0;
			end else begin
				if (ptw_req_hsk) begin
					ptw_req_outstanding_req_r <= 1'b1;
				end
				if (ptw_res_hsk) begin
					ptw_req_outstanding_req_r <= 1'b0;
				end
			end
		end

		reg [riscv::VLEN-1:0] itlb_iface_transid_data_model;	//Signal Generated by AUTOSVA
		reg [riscv::VLEN-1:0] dtlb_iface_transid_data_model;	//Signal Generated by AUTOSVA

		always_ff @(posedge clk_i) begin
			if(!rst_ni) begin
				itlb_iface_transid_data_model <= '0;
			end else if (itlb_iface_transid_set) begin
				itlb_iface_transid_data_model <= itlb_data;
			end
		end
		always_ff @(posedge clk_i) begin
			if(!rst_ni) begin
				dtlb_iface_transid_data_model <= '0;
			end else if (dtlb_iface_transid_set) begin
				dtlb_iface_transid_data_model <= dtlb_data;
			end
		end

    Symbolics: Unconstrained, verification tool explores all possible values

	ASSERT_INPUTS:
	- Doesn't seem like it is going to 1 considering _bind.svh. Therefore, all signals dependent on this condition are constrained using assume, not asserted

	ASSERT_INPUTS Assumptions:
    - am__itlb_iface_transid_sample_no_overflow:        constrains itlb_iface_transid_sampled != '1 OR !itlb_iface_transid_set
	- am__dtlb_iface_transid_sample_no_overflow:        constrains dtlb_iface_transid_sampled != '1 OR !dtlb_iface_transid_set
    - am__itlb_iface_transid_stability:                 if (itlb_val AND !itlb_rdy), then (itlb_val AND itlb_stable is stable)
	- am__dtlb_iface_transid_stability:                 if (dtlb_val AND !dtlb_rdy), then (dtlb_val AND dtlb_stable is stable)
    - am__ptw_req_fairness:                             if ptw_req_val, constrains ptw_req_rdy to be set
    - am__ptw_req1:                                     if ptw_req_outstanding_req_r[j] is not set, constrains ptw_res_val to not set
    - am__ptw_req2:                                     if ptw_req_outstanding_req_r[j] is set, constrains ptw_res_val to be eventually set

	ASSERT_INPUTS Assertions:
	- ... same as assumptions

	ASSERT_INPUTS Covers: Assertion cannot fail, Cover can fail
	- co__ptw_req: 										flag simulation as covered if ptw_req_outstanding_req_r[j] is set

    Autogenerated Assertions:
    - as__itlb_iface_transid_active:                    if itlb_iface_transid_sampled has set bit, itlb_iface_active needs to be set
	- as__dtlb_iface_transid_active: 					if dtlb_iface_transid_sampled has set bit, then dtlb_iface_active needs to be set
	- as__itlb_iface_transid_hsk_or_drop: 				if itlb_val is set, eventually itlb_val needs to be not set OR itlb_rdy needs to be set
	- as__dtlb_iface_transid_hsk_or_drop: 				if dtlb_val is set, eventually dtlb_val needs to be not set OR dtlb_rdy needs to be set
	- as__itlb_iface_transid_eventual_response: 		itlb_iface_transid_sampled is set on any bits, eventually itlb_update_val is set
	- as__dtlb_iface_transid_eventual_response: 		if dtlb_iface_transid_sampled has set bit, then eventually dtlb_update_val
	- as__itlb_iface_transid_was_a_request: 			if itlb_iface_transid_response is set, then itlb_iface_transid_set needs to be set OR itlb_iface_transid_sampled has a set bit
	- as__dtlb_iface_transid_was_a_request: 			if dtlb_update_val, then dtlb_iface_transid_set needs to be set  OR dtlb_iface_transid_sampled has a set bit
	- as__itlb_iface_transid_data_unique: 				if itlb_iface_transid_sampled has a set bit, then itlb_iface_transid_set needs to be not set
	- as__dtlb_iface_transid_data_unique: 				if dtlb_iface_transid_sampled has a set bit, then dtlb_iface_transid_set needs to be not set
	- as__itlb_iface_transid_data_integrity: 			if itlb_iface_transid_sampled has set bit AND itlb_iface_transid_response is set, then itlb_update_data need to be == itlb_iface_transid_data_model
	- as__dtlb_iface_transid_data_integrity: 			if dtlb_iface_transid_sampled has set bit AND dtlb_iface_transid_response is set, then dtlb_update_data need to be == dtlb_iface_transid_data_model
	
	Autogenerated Covers: Assertion cannot fail, Cover can fail
	- co__itlb_iface_transid_sampled: 					flag simulation as covered if itlb_iface_transid_sampled has set bit
	- co__dtlb_iface_transid_sampled: 					flag simulation as covered if dtlb_iface_transid_sampled has set bit

	X PROPAGATION ASSERTIONS: Checks all bits are not 'x' or 'z'
	- as__no_x_dtlb_update_val: 						!$isunknown(dtlb_update_val)
	- as__no_x_dtlb_update_data: 						if dtlb_update_val is set, !$isunknown(dtlb_update_data)
	- as__no_x_dtlb_val: 								!$isunknown(dtlb_val)
	- as__no_x_dtlb_data: 								if dtlb_val is set, !$isunknown(dtlb_data)
	- as__no_x_dtlb_stable: 							if dtlb_val is set, !$isunknown(dtlb_stable)
	- as__no_x_itlb_update_val: 						!$isunknown(itlb_update_val)
	- as__no_x_itlb_update_data: 						if itlb_update_val is set, !$isunknown(itlb_update_data)
	- as__no_x_itlb_val: 								!$isunknown(itlb_val)
	- as__no_x_itlb_stable: 							if itlb_val is set, !$isunknown(itlb_stable)
	- as__no_x_itlb_data: 								if itlb_val is set, !$isunknown(itlb_data)
*/

module ptw_prop
 import ariane_pkg::*; #(
		parameter ASSERT_INPUTS = 0,
		parameter int ASID_WIDTH = 1,
		parameter ariane_pkg::ariane_cfg_t ArianeCfg = ariane_pkg::ArianeDefaultConfig
) (
		input  logic                    clk_i,                  // Clock
		input  logic                    rst_ni,                 // Asynchronous reset active low
		input  logic                    flush_i,                // flush everything, we need to do this because
		// actually everything we do is speculative at this stage
		// e.g.: there could be a CSR instruction that changes everything
		input  logic                    ptw_active_o, //output
		input  logic                    walking_instr_o,        // set when walking for TLB //output
		input  logic                    ptw_error_o,            // set when an error occurred //output
		input  logic                    ptw_access_exception_o, // set when an PMP access exception occured //output
		input  logic                    enable_translation_i,   // CSRs indicate to enable SV39
		input  logic                    en_ld_st_translation_i, // enable virtual memory translation for load/stores
		
		input  logic                    lsu_is_store_i,         // this translation was triggered by a store
		// PTW memory interface
		input  dcache_req_o_t           req_port_i,
		input  dcache_req_i_t           req_port_o, //output
		
		
		// to TLBs, update logic
		input  tlb_update_t             itlb_update_o, //output
		input  tlb_update_t             dtlb_update_o, //output
		
		input  logic [riscv::VLEN-1:0]  update_vaddr_o, //output
		
		input  logic [ASID_WIDTH-1:0]   asid_i,
		// from TLBs
		// did we miss?
		input  logic                    itlb_access_i,
		input  logic                    itlb_hit_i,
		input  logic [riscv::VLEN-1:0]  itlb_vaddr_i,
		
		input  logic                    dtlb_access_i,
		input  logic                    dtlb_hit_i,
		input  logic [riscv::VLEN-1:0]  dtlb_vaddr_i,
		// from CSR file
		input  logic [riscv::PPNW-1:0]  satp_ppn_i, // ppn from satp
		input  logic                    mxr_i,
		// Performance counters
		input  logic                    itlb_miss_o, //output
		input  logic                    dtlb_miss_o, //output
		// PMP
		
		input  riscv::pmpcfg_t [15:0]   pmpcfg_i,
		input  logic [15:0][53:0]       pmpaddr_i,
		input  logic [riscv::PLEN-1:0]  bad_paddr_o //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk_i);
endclocking
default disable iff (!rst_ni);

// Re-defined wires 
wire ptw_req_val;
wire ptw_req_rdy;
wire ptw_res_val;
wire itlb_iface_active;
wire itlb_val;
wire itlb_rdy;
wire [riscv::VLEN-1:0] itlb_stable;
wire [riscv::VLEN-1:0] itlb_data;
wire itlb_iface_transid_sampled + itlb_iface_transid_set - itlb_iface_transid_response;
wire [riscv::VLEN-1:0] itlb_update_data;
wire dtlb_iface_active;
wire dtlb_val;
wire dtlb_rdy;
wire [riscv::VLEN-1:0] dtlb_stable;
wire [riscv::VLEN-1:0] dtlb_data;
wire dtlb_update_val;
wire [riscv::VLEN-1:0] dtlb_update_data;

// Symbolics and Handshake signals
wire itlb_update_hsk = itlb_update_val;
wire itlb_hsk = itlb_val && itlb_rdy;
wire ptw_res_hsk = ptw_res_val;
wire ptw_req_hsk = ptw_req_val && ptw_req_rdy;
wire dtlb_update_hsk = dtlb_update_val;
wire dtlb_hsk = dtlb_val && dtlb_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for itlb_iface
// Generate sampling signals and model
reg [3:0] itlb_iface_transid_sampled;
wire itlb_iface_transid_set = itlb_hsk;
wire itlb_iface_transid_response = itlb_update_hsk;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		itlb_iface_transid_sampled <= '0;
	end else if (itlb_iface_transid_set || itlb_iface_transid_response ) begin
		itlb_iface_transid_sampled <= itlb_iface_transid_sampled + itlb_iface_transid_set - itlb_iface_transid_response;
	end
end
co__itlb_iface_transid_sampled: cover property (|itlb_iface_transid_sampled);
if (ASSERT_INPUTS) begin
	as__itlb_iface_transid_sample_no_overflow: assert property (itlb_iface_transid_sampled != '1 || !itlb_iface_transid_set);
end else begin
	am__itlb_iface_transid_sample_no_overflow: assume property (itlb_iface_transid_sampled != '1 || !itlb_iface_transid_set);
end

as__itlb_iface_transid_active: assert property (itlb_iface_transid_sampled > 0 |-> itlb_iface_active);

// Assume payload is stable and valid is non-dropping
if (ASSERT_INPUTS) begin
	as__itlb_iface_transid_stability: assert property (itlb_val && !itlb_rdy |=> itlb_val && $stable(itlb_stable) );
end else begin
	am__itlb_iface_transid_stability: assume property (itlb_val && !itlb_rdy |=> itlb_val && $stable(itlb_stable) );
end

// Assert that if valid eventually ready or dropped valid
as__itlb_iface_transid_hsk_or_drop: assert property (itlb_val |-> s_eventually(!itlb_val || itlb_rdy));
// Assert that every request has a response and that every reponse has a request
as__itlb_iface_transid_eventual_response: assert property (|itlb_iface_transid_sampled |-> s_eventually(itlb_update_val));
as__itlb_iface_transid_was_a_request: assert property (itlb_iface_transid_response |-> itlb_iface_transid_set || itlb_iface_transid_sampled);


// Modeling data integrity for itlb_iface_transid
reg [riscv::VLEN-1:0] itlb_iface_transid_data_model;
always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		itlb_iface_transid_data_model <= '0;
	end else if (itlb_iface_transid_set) begin
		itlb_iface_transid_data_model <= itlb_data;
	end
end

as__itlb_iface_transid_data_unique: assert property (|itlb_iface_transid_sampled |-> !itlb_iface_transid_set);
as__itlb_iface_transid_data_integrity: assert property (|itlb_iface_transid_sampled && itlb_iface_transid_response |-> (itlb_update_data == itlb_iface_transid_data_model));

// Modeling outstanding request for ptw_req
reg [1-1:0] ptw_req_outstanding_req_r;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		ptw_req_outstanding_req_r <= '0;
	end else begin
		if (ptw_req_hsk) begin
			ptw_req_outstanding_req_r <= 1'b1;
		end
		if (ptw_res_hsk) begin
			ptw_req_outstanding_req_r <= 1'b0;
		end
	end
end


generate
if (ASSERT_INPUTS) begin : ptw_req_gen
	as__ptw_req1: assert property (!ptw_req_outstanding_req_r |-> !(ptw_res_hsk));
	as__ptw_req2: assert property (ptw_req_outstanding_req_r |-> s_eventually(ptw_res_hsk));
end else begin : ptw_req_else_gen
	am__ptw_req_fairness: assume property (ptw_req_val |-> s_eventually(ptw_req_rdy));
	for ( j = 0; j < 1; j = j + 1) begin : ptw_req_for_gen
		co__ptw_req: cover property (ptw_req_outstanding_req_r[j]);
		am__ptw_req1: assume property (!ptw_req_outstanding_req_r[j] |-> !(ptw_res_val));
		am__ptw_req2: assume property (ptw_req_outstanding_req_r[j] |-> s_eventually(ptw_res_val));
	end
end
endgenerate

// Modeling incoming request for dtlb_iface
// Generate sampling signals and model
reg [3:0] dtlb_iface_transid_sampled;
wire dtlb_iface_transid_set = dtlb_hsk;
wire dtlb_iface_transid_response = dtlb_update_hsk;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		dtlb_iface_transid_sampled <= '0;
	end else if (dtlb_iface_transid_set || dtlb_iface_transid_response ) begin
		dtlb_iface_transid_sampled <= dtlb_iface_transid_sampled + dtlb_iface_transid_set - dtlb_iface_transid_response;
	end
end
co__dtlb_iface_transid_sampled: cover property (|dtlb_iface_transid_sampled);
if (ASSERT_INPUTS) begin
	as__dtlb_iface_transid_sample_no_overflow: assert property (dtlb_iface_transid_sampled != '1 || !dtlb_iface_transid_set);
end else begin
	am__dtlb_iface_transid_sample_no_overflow: assume property (dtlb_iface_transid_sampled != '1 || !dtlb_iface_transid_set);
end

as__dtlb_iface_transid_active: assert property (dtlb_iface_transid_sampled > 0 |-> dtlb_iface_active);

// Assume payload is stable and valid is non-dropping
if (ASSERT_INPUTS) begin
	as__dtlb_iface_transid_stability: assert property (dtlb_val && !dtlb_rdy |=> dtlb_val && $stable(dtlb_stable) );
end else begin
	am__dtlb_iface_transid_stability: assume property (dtlb_val && !dtlb_rdy |=> dtlb_val && $stable(dtlb_stable) );
end

// Assert that if valid eventually ready or dropped valid
as__dtlb_iface_transid_hsk_or_drop: assert property (dtlb_val |-> s_eventually(!dtlb_val || dtlb_rdy));
// Assert that every request has a response and that every reponse has a request
as__dtlb_iface_transid_eventual_response: assert property (|dtlb_iface_transid_sampled |-> s_eventually(dtlb_update_val));
as__dtlb_iface_transid_was_a_request: assert property (dtlb_iface_transid_response |-> dtlb_iface_transid_set || dtlb_iface_transid_sampled);


// Modeling data integrity for dtlb_iface_transid
reg [riscv::VLEN-1:0] dtlb_iface_transid_data_model;
always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		dtlb_iface_transid_data_model <= '0;
	end else if (dtlb_iface_transid_set) begin
		dtlb_iface_transid_data_model <= dtlb_data;
	end
end

as__dtlb_iface_transid_data_unique: assert property (|dtlb_iface_transid_sampled |-> !dtlb_iface_transid_set);
as__dtlb_iface_transid_data_integrity: assert property (|dtlb_iface_transid_sampled && dtlb_iface_transid_response |-> (dtlb_update_data == dtlb_iface_transid_data_model));

assign ptw_req_val = req_port_o.data_req;
assign dtlb_data = dtlb_vaddr_i;
assign itlb_update_val = itlb_update_o.valid || walking_instr_o && (ptw_access_exception_o || ptw_error_o || ptw_active_o && flush_i);
assign dtlb_update_val = dtlb_update_o.valid || !walking_instr_o && (ptw_access_exception_o || ptw_error_o || ptw_active_o && flush_i);
assign dtlb_val = en_ld_st_translation_i & dtlb_access_i & ~dtlb_hit_i & !flush_i;
assign dtlb_iface_active = ptw_active_o;
assign itlb_stable = itlb_vaddr_i;
assign dtlb_stable = dtlb_vaddr_i;
assign itlb_val = enable_translation_i & itlb_access_i & ~itlb_hit_i & ~dtlb_access_i & !flush_i;
assign ptw_req_rdy = req_port_i.data_gnt;
assign itlb_rdy = !ptw_active_o;
assign dtlb_rdy = !ptw_active_o;
assign dtlb_update_data = update_vaddr_o;
assign itlb_update_data = update_vaddr_o;
assign itlb_data = itlb_vaddr_i;
assign itlb_iface_active = ptw_active_o;
assign ptw_res_val = req_port_i.data_rvalid;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_dtlb_update_val: assert property(!$isunknown(dtlb_update_val));
	 as__no_x_dtlb_update_data: assert property(dtlb_update_val |-> !$isunknown(dtlb_update_data));
	 as__no_x_dtlb_val: assert property(!$isunknown(dtlb_val));
	 as__no_x_dtlb_data: assert property(dtlb_val |-> !$isunknown(dtlb_data));
	 as__no_x_dtlb_stable: assert property(dtlb_val |-> !$isunknown(dtlb_stable));
	 as__no_x_itlb_update_val: assert property(!$isunknown(itlb_update_val));
	 as__no_x_itlb_update_data: assert property(itlb_update_val |-> !$isunknown(itlb_update_data));
	 as__no_x_itlb_val: assert property(!$isunknown(itlb_val));
	 as__no_x_itlb_stable: assert property(itlb_val |-> !$isunknown(itlb_stable));
	 as__no_x_itlb_data: assert property(itlb_val |-> !$isunknown(itlb_data));
`endif

endmodule