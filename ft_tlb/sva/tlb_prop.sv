// This property file was autogenerated by AutoSVA on 2023-09-17
// to check the behavior of the original RTL module, whose interface is described below: 


module tlb_prop
 import ariane_pkg::*; #(
		parameter ASSERT_INPUTS = 0,
		parameter int unsigned TLB_ENTRIES = 4,
		parameter int unsigned ASID_WIDTH  = 1
)(
		input  logic                    clk_i,    // Clock
		input  logic                    rst_ni,   // Asynchronous reset active low
		input  logic                    flush_i,  // Flush signal
		// Update TLB
		input  tlb_update_t             update_i,
		// Lookup signals
		input  logic                    lu_access_i,
		input  logic [ASID_WIDTH-1:0]   lu_asid_i,
		input  logic [riscv::VLEN-1:0]  lu_vaddr_i,
		input  riscv::pte_t             lu_content_o, //output
		input  logic [ASID_WIDTH-1:0]   asid_to_be_flushed_i,
		input  logic [riscv::VLEN-1:0]  vaddr_to_be_flushed_i,
		input  logic                    lu_is_2M_o, //output
		input  logic                    lu_is_1G_o, //output
		input  logic                    lu_hit_o //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk_i);
endclocking
default disable iff (!rst_ni);

// Re-defined wires 
wire lk_req_val;
wire lk_req_rdy;
wire [riscv::VLEN+ASID_WIDTH-1:0] lk_req_stable;
wire lk_res_val;
wire miss_val;
wire [27:0] miss_data;
wire alloc_val;
wire [27:0] alloc_data;

// Symbolics and Handshake signals
wire lk_res_hsk = lk_res_val;
wire lk_req_hsk = lk_req_val && lk_req_rdy;
wire alloc_hsk = alloc_val;
wire miss_hsk = miss_val;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for lookup
// Generate sampling signals and model
reg [3:0] lookup_transid_sampled;
wire lookup_transid_set = lk_req_hsk;
wire lookup_transid_response = lk_res_hsk;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		lookup_transid_sampled <= '0;
	end else if (lookup_transid_set || lookup_transid_response ) begin
		lookup_transid_sampled <= lookup_transid_sampled + lookup_transid_set - lookup_transid_response;
	end
end
if (ASSERT_INPUTS) begin
	as__lookup_transid_sample_no_overflow: assert property (lookup_transid_sampled != '1 || !lookup_transid_set);
end else begin
	am__lookup_transid_sample_no_overflow: assume property (lookup_transid_sampled != '1 || !lookup_transid_set);
end


// Assume payload is stable and valid is non-dropping
if (ASSERT_INPUTS) begin
	as__lookup_transid_stability: assert property (lk_req_val && !lk_req_rdy |=> lk_req_val && $stable(lk_req_stable) );
end else begin
	am__lookup_transid_stability: assume property (lk_req_val && !lk_req_rdy |=> lk_req_val && $stable(lk_req_stable) );
end

// Assert that if valid eventually ready or dropped valid
//as__lookup_transid_hsk_or_drop: assert property (lk_req_val |-> s_eventually(!lk_req_val || lk_req_rdy));

// Assert that every request has a response and that every reponse has a request
as__lookup_transid_eventual_response: assert property (|lookup_transid_sampled |-> s_eventually(lk_res_val));
as__lookup_transid_was_a_request: assert property (lookup_transid_response |-> lookup_transid_set || lookup_transid_sampled);

// Modeling outstanding request for update
reg [1-1:0] update_outstanding_req_r;
reg [1-1:0][27:0] update_outstanding_req_data_r;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		update_outstanding_req_r <= '0;
	end else begin
		if (miss_hsk) begin
			update_outstanding_req_r <= 1'b1;
			update_outstanding_req_data_r <= miss_data;
		end
		if (alloc_hsk) begin
			update_outstanding_req_r <= 1'b0;
		end
	end
end


generate
if (ASSERT_INPUTS) begin : update_gen
	as__update1: assert property (!update_outstanding_req_r |-> !(alloc_hsk));
	as__update2: assert property (update_outstanding_req_r |-> s_eventually(alloc_hsk&&
	 (alloc_data == update_outstanding_req_data_r) ));
end else begin : update_else_gen
	for ( j = 0; j < 1; j = j + 1) begin : update_for_gen
		co__update: cover property (update_outstanding_req_r[j]);
		am__update1: assume property (!update_outstanding_req_r[j] |-> !(alloc_val));
		am__update2: assume property (update_outstanding_req_r[j] |-> s_eventually(alloc_val&&
	 (alloc_data == update_outstanding_req_data_r[j]) ));
	end
end
endgenerate

assign alloc_data = {update_i.asid,update_i.vpn};
assign lk_req_stable = {lu_vaddr_i, lu_asid_i};
assign miss_val = lu_access_i && !lu_hit_o;
assign alloc_val = update_i.valid;
assign lk_res_val = lu_access_i && lu_hit_o;
assign lk_req_rdy = lu_access_i && lu_hit_o;
assign lk_req_val = lu_access_i;
assign miss_data = {lu_asid_i,lu_vaddr_i[38:12]};

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_miss_val: assert property(!$isunknown(miss_val));
	 as__no_x_miss_data: assert property(miss_val |-> !$isunknown(miss_data));
	 as__no_x_alloc_val: assert property(!$isunknown(alloc_val));
	 as__no_x_alloc_data: assert property(alloc_val |-> !$isunknown(alloc_data));
	 as__no_x_lk_req_val: assert property(!$isunknown(lk_req_val));
	 as__no_x_lk_req_stable: assert property(lk_req_val |-> !$isunknown(lk_req_stable));
`endif



//====DESIGNER-ADDED-SVA====//


// PROPERTY FILE CONTENT

// Check that the lookup hits exactly once when the lu_hit_o is asserted
asgpt__single_lookup_hit: 
assert property (tlb.lu_hit_o |-> $countones(tlb.lu_hit) == 1);

// Check that if flush is enabled and both addresses to be flushed are zero, all entries are invalidated
asgpt__flush_all:
assert property (tlb.flush_i & tlb.asid_to_be_flushed_is0 & tlb.vaddr_to_be_flushed_is0 
                 |=> $countones({tlb.tags_q[TLB_ENTRIES-1:0]}) == 0);

// When lookup is accessed and there's a hit, plru_tree should be updated
asgpt__plru_tree_update:
assert property (tlb.lu_access_i & tlb.lu_hit_o 
                 |=> $past(tlb.plru_tree_q) !== tlb.plru_tree_n);

// Check that the translation hit should update the lu_content_o to the matching content_q
genvar i;
generate
    for(i=0; i<TLB_ENTRIES; i++) begin
        asgpt__translation_content_update:
        assert property (tlb.lu_hit[i] |-> tlb.lu_content_o == tlb.content_q[i]);

		// Check that if an update is valid, the content should be updated in the next cycle for the replacing entry
		asgpt__update_entry:
		assert property (tlb.update_i.valid & tlb.replace_en[i]
                 |=> tlb.content_q[i] == tlb.update_i.content && tlb.tags_q[i].valid);


		// When a translation hit occurs with is_1G flag, the lu_is_1G_o output should also be asserted
		asgpt__translation_is_1G:
		assert property (tlb.lu_hit_o & tlb.tags_q[i].is_1G 
						|-> tlb.lu_is_1G_o);

		// When a translation hit occurs with is_2M flag and vpn0 matches, the lu_is_2M_o output should be asserted
		asgpt__translation_is_2M:
		assert property (tlb.lu_hit_o & tlb.tags_q[i].is_2M & (tlb.vpn0 == tlb.tags_q[i].vpn0) 
						|-> tlb.lu_is_2M_o);
    end
endgenerate


// Check that if a flush is active, and the vaddr_to_be_flushed matches one of the entries in the TLB, that entry should be invalidated
generate
    for(i=0; i<TLB_ENTRIES; i++) begin
        asgpt__flush_single_entry:
        assert property (tlb.flush_i & tlb.vaddr_vpn0_match[i] & tlb.vaddr_vpn1_match[i] & tlb.vaddr_vpn2_match[i] 
                         |=> !tlb.tags_q[i].valid);


		// When lookup hits and a global page (g flag set) matches, it should be regardless of the ASID value
		asgpt__global_page_asid_ignore:
		assert property (tlb.lu_hit_o & tlb.content_q[i].g 
						|-> (tlb.lu_asid_i == tlb.tags_q[i].asid));
    end
endgenerate


endmodule