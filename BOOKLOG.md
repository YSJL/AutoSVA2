
## T1

Generated 4 assertions.

### Issue

buffer_head_r' is not declared

### Reason

Internal signal is not visible inside the property file.

### Change

NOTE that signals declared within the AUTOSVA section are also usable.
NOTE that to reference internal signals (not present in the module interface) you need to write the name of the module before the signal name, followed by a '.'


## T2

Generated 6 assertions.

### Issue

Issue: syntax error. used wrong syntax to assert property. always @(posedge clk) instead of assert
buffer_head_r' is not declared

### Reason

Hallucionation?
Observation: it skipped the module signal declaration, likely because it realized it wrote it already before.

### Change

Ask in a separate context.

## T3

Generated 8 assertions.

### Issue

SystemVerilog keyword foreach used in incorrect context
Observation: Wrote assertion in separate code sections, so I had to manually copy them over.


### Reason

Invalid syntax.


### Change


Ask to put all assertions in the same code section.
Prompted again givin the error message "syntax error near 'foreach'"


## T4

Generated 4 assertions.

### Issue

Same as T1.


### Reason

NOTE explaining the hierarchy of the module and the signals not effective.

### Change

LEARN: to reference internal signals (not present in the module interface) you need to write the name of the module before the signal name, e.g., fifo.buffer_head_r
LEARN: write all assertions within the same sva property file, but do not rewrite the module interface.


## T5

Generated 9 assertions.

### Issues

1. Wrongly included `include "fifo.sv" in the property file. Manually fixed it, and then it compiled.
2. Assertions are not named, so it reads as assertion 1, 2, 3, etc.
3. Some assertions have (!rst_n) as precondition. The autogenerated witness covers for the precondition is unreachable, because the FPV tool starts as reset. Since we are not interested in the reset state, we can remove the reset assertions.
4. (in_val && in_rdy) |-> ($past(fifo.buffer_head_r) + 1'b1 === fifo.buffer_head_r). It didn't realize that the register is updated in the next cycle, so it should not be a same-cycle assertion (|->).

### Reason

It realized it is a property file, so it attempted to include the DUT file. But it wrongly assumed it was a SystemVerilog file .sv, when it was a .v file.
Observation: Now that it realized it is a property file, it generates more properties than before.
It also declares them as properties and asserts them separately.

### Change

1 ".. do not add includes"
2. "Give appropiate names to the assertions "as__<NAME> : assert" and make them as high-level as possible, avoid repeating implementation details"
3. "Write SVA assertions ... but the reset behavior."
4. Explain how assertion implication works. "LEARN: |-> is a same-cycle assertion (the antecedent and consequent are evaluated in the same cycle)
LEARN: |=> is a next-cycle assertion (the antecedent is evaluated in the current cycle and the consequent in the next cycle)"

## T6

Generated 6 assertions.

### Issue

Compile error.

property as__PushCorrectness;
  @(posedge clk) in_val && in_rdy |-> fifo.buffer_head_r == $past(fifo.buffer_head_r) + 1;
endproperty

as__PushCorrectness : assert property (as__PushCorrectness);


### Reason

Gave same name twice.

### Change

Give appropiate names to properties pr__<NAME> and assertions "as__<NAME> : assert" and make them as high-level as possible, avoid repeating implementation details.

## T7

Generated 6 assertions.

### Issue
Compiled. 4 assertions failed.


### Reason
Still didn't get that the register is updated in the next cycle, so it should not be a same-cycle assertion (|->).
property pr__increment_head;
    @(posedge clk) 
    in_hsk |-> (fifo.buffer_head_r == $past(fifo.buffer_head_r) + 1);
endproperty


### Change

LEARN: signals ending in _r represent flip-flops (registers) and thus, the updated value becomes available in the next cycle
LEARN: signals not ending in _r represent combinational logic and thus, the updated value is available in the current cycle.

## T8

Generated 6 assertions.

### Issue
1. No compile. It missed the fifo prefix in one signal (add_buffer). Fixed it and then it compiled. 3 assertions failed.
2. It also generated the interface signal of the property file. Nudge not to do that

### Change

1. Nudge more on the hierarchy of signal names. "LEARN: Internal signals are the signals that are not present in the module interface.
LEARN: Using internal signals in the property file requires to prepend the name of the module before the signal name, e.g., fifo.buffer_head_r"
2. Nudge more on not generating the interface signal of the property file. "LEARN: SVA assertions are written within a property file. DO NOT rewrite the module interface and do not add includes in the property file as we already have them in the property file."



## T9

Generated 5 assertions.

### Issue

1. No compile. It still misses the module prefix.
2. It ignored the part of the prompt that said no to add imports not module declaration name. It also gave explanations of what was going to do, which I said not to do.
I suspect it may be "forgetting" the rules we establish in the preambule of the prompt.

### Change

Explain the rules after the module


## T10

Generated 9 assertions.

### Issue
Compiled! 5 assertions failed.

### Change

When combinational logic is used on the consequent of a next-cycle assertion, the antecedent must be evaluated in the current cycle.
(fifo.in_val && fifo.in_rdy) |=> (fifo.out_val && fifo.out_rdy) -> (fifo.in_data == fifo.buffer_data_r[fifo.buffer_tail_r]);


## T11

Generated 7 assertions.

### Issue
Compiled! 1 assertions failed.
in_hsk |=> fifo.buffer_data_r[fifo.buffer_head_r] == in_data;
it's missing $past in the consequent.
in_hsk |=> fifo.buffer_data_r[$past(fifo.buffer_head_r)] == $past(in_data);

### Change

Since we added more rules, let's be more concise to, grouping LEARN section.
We can also ask it to not give property names, to save context.


## T12

Generated 10 assertions.

### Issue
Compiled. 7 assertions failed.
Using $past too much now, when in reality it wants the current value.

as__buffer_slot_free_on_in_hsk : assert property (
    fifo.in_hsk |-> !fifo.buffer_val_r[$past(fifo.buffer_head_r)]
);

### Change

Updated rules about $past.


## T13

Generated 9 assertions.

### Issue
Not compiled.
syntax error near 'foreach'
	[ERROR (VERI-2344)] SystemVerilog keyword foreach used in incorrect context

### Change
Rule do not use foreach
Observation: the more instructions we give the more assertions it creates. It seems to realize about more behavior to check.


## T14

Generated 12 assertions.

### Issue
Compiled! 4 assertions failed.

1. No wrap-around.
as__in_hsk_increment_head: assert property (fifo.in_hsk |=> fifo.buffer_head_r == $past(fifo.buffer_head_r) + 1);
as__out_hsk_increment_tail: assert property (fifo.out_hsk |=> fifo.buffer_tail_r == $past(fifo.buffer_tail_r) + 1);

2. Confused val with counter. It should say never all slots are valid.
as__in_rdy_invalid_slot_exists: assert property(fifo.in_rdy |-> fifo.buffer_val_r !== fifo.INFLIGHT)
!fifo.in_rdy |-> fifo.buffer_val_r === fifo.INFLIGHT

### Change

Add code Annotations as HINTS, do not change the RULES



## T15

Generated 8 assertions.

### Issue
Compiled! 2 different assertions failed. It fixed the last issues.
1. It added the width of the  + 1'b1
2. It realized about the bitmask.

It used a next-cycle assertion when it should be a same-cycle assertion.
for (k = 0; k < INFLIGHT; k = k + 1) begin: buffer_operations_gen
	as__input_handshake_add_buffer_flagged : assert property (in_val && in_rdy && (fifo.buffer_head_r == k) |=> fifo.add_buffer[k]);
end

It should have used $past(in_data)
as__input_handshake_data_load : assert property (in_val && in_rdy |=> fifo.buffer_data_r[fifo.buffer_head_r] == in_data);

### Change

Add RULE, signals without _r are combinational logic and thus, the updated value is available in the current cycle.



## T16

Generated 9 assertions.

### Issue
Compiled. 4 assertions failed.

1. All buffers invalid is not the same as not all buffers valid.
as__out_val_low_if_all_buffer_invalid: assert property ( (!&fifo.buffer_val_r) |-> fifo.out_val == 0'b0);

2. it should have used $past for one flip-flop.
fifo.in_hsk |=> fifo.buffer_val_r[fifo.buffer_head_r] == 1'b1

### Change

When referencing flip-flops on the consequent of a next-cycle assertion (|=>), we USE $past() to refer to the value of the flip-flop on the cycle of the antecedent.
!&bitarray means that not all bits in bitarray are 1. !(|bitarray) means that not any bit in bitarray is 1.


## T17

Generated 8 assertions.


### Issue
Compiled. 3 assertion failed.
Similar issue. Should have used |= instead of |->
fifo.add_buffer[i] |-> fifo.buffer_data_r[i] == $past(fifo.in_data)

### Change

Clearly identify registers and combinational logic.



## T18

Generated 10 assertions.

### Issue
Does not compile. Assertion name.

generate
  for (i = 0; i < 2**fifo.INFLIGHT_IDX; i = i + 1) begin : buffer_val_gen
    as__buffer_val_set[i]: 

can't name assertion as an array.
Once this was fixed, the rest of the assertions passed.

### Change

Tell it to not name assertions as arrays.

## T19

Generated 12 assertions.


### Issue
Does not compile.
After fixing that, 2 assertions failed.

1. Assertion without precondition still using operator |->.

2. Mixed the Comment and behavior of the assertions

// Assertion to check that out_val is high if any buffer is valid.
as_fifo_out_val_high_on_any_buffer_valid: assert property (
    !(|fifo.buffer_val_flipflop) |-> fifo.out_val == 1'b0
);

// Assertion to check that out_val is low if all buffers are invalid.
as_fifo_out_val_low_on_all_buffer_invalid: assert property (
    !&fifo.buffer_val_flipflop |-> fifo.out_val == 1'b1
);

### Change

1. Add rule: assertions without precondition are always evaluated.
2. Improve rule about !& behavior.


## T20

Generated 10 assertions.

### Issue
Does not compile.
Because we forced it to declare width, it correctly identified the width of the counter.
However, INFLIGHT_IDX'1 is not Verilog syntax if INFLIGHT_IDX is a parameter.
It instead should use concatenation {INFLIGHT_IDX-1{1'b0}, 1'b1}.
This can get messy, so we decide to remove the rule about declaring width.

There is also an assertion that should have used a next-cycle implication, but it used a same-cycle implication.
fifo.add_buffer[i] |-> fifo.buffer_data_flipflop[i] == fifo.in_data
so we should further nudge about the difference between |-> and |=>.

### Change

We refactor all mentions to flipflop to register, to see if that naming works better
We also refine the rules about registers.

## T21

Generated 7 assertions.

### Issue
Compile. 1 assertion fails.
It should have used $past for the register.

### Change

Let's ask to explain more the behavior of the assertion to see if it realizes by itself.

## T22

Generated 9 assertions.

### Issue
Compile. 1 assertion fails.
The $past on the precondition is wrong.
as__retain_data_in_buffer: assert property (($past(fifo.buffer_val_reg[i]) && !fifo.clr_buffer[i]) |=> fifo.buffer_val_reg[i]);


### Change

Forbid the use of $past on the precondition.

## T23

Generated 8 assertions.
Compile. 0 assertion fails.
FULL PROOF!


## T24

Generated 8 assertions.
Compile. 1 assertion fails.
// Ensure that when 'out_val' is high and 'out_rdy' is not set, then the FIFO is empty
as__fifo_empty_when_not_valid:
assert property (fifo.out_val && !fifo.out_rdy |-> !(|fifo.buffer_val_reg));

out_rdy is an input from the consumer of the FIFO, so it's behavior depends on the consumer.
GPT4 made a wrong assumption that if the consumer does not want to read, it's because the FIFO is empty.
This is interesting behavior, which demonstrates that there is a variety of SVA properties that can be written for the same design.

It's a bit like fuzzy testing, but with formal verification.
Out of 8 assertions each test, only 2 are the same (the head and tail increment ones).
The rest are slight variations to test similar behavior. For example:
CHECKS DATA INTEGRITY IN TWO DIFFERENT WAYS.

// If a slot is selected to add data, the next cycle that slot should have the input data.
as__add_data_to_buffer: assert property (fifo.add_buffer[i] |=> fifo.buffer_data_reg[i] == $past(fifo.in_data));


generate
    for (genvar i = 0; i < INFLIGHT; i = i + 1) begin: check_data_on_write
        as__data_correctly_written:
        assert property (fifo.in_hsk && !(|fifo.buffer_val_reg) && (fifo.buffer_head_reg == i) |=> fifo.buffer_data_reg[i] == $past(fifo.in_data));
    end
endgenerate

WE TESTED BOTH SETS OF ASSERTIONS, AND THERE IS NO PERFORMANCE DISADVANTAGE IN WRITING MORE ASSERTIONS in this case.
The tool probably smart enough to realize that the assertions are similar and it can reuse the same witness for both.



## T25

NO SENSITIVITY TO SIGNAL NAMES: modul

No Compile. All assertion pass.
No compile. Made up a function that does not exist.
assert property (sum(int i = 0; i < modul.INFLIGHT; i = i + 1) modul.buffer_val_reg[i] <= modul.INFLIGHT);

It meant to do: assert property ($countones(modul.buffer_val_reg) <= modul.INFLIGHT);
But once we fixed that, the rest of assertions passed!
We add a new rule about $countones.


## T26
Compile. 1 assertion fails.
NO SENSITIVITY TO SIGNAL NAMES: multiplier

It failed to realize that buffer_data_reg is not the data "being added", but the register that stores the data.
// Checks that the data being added to the buffer on an input handshake is the same 
// as the input data
as__buffer_data_matches_input_data:
    assert property (
        multiplier.add_buffer[i] |-> (multiplier.buffer_data_reg[i] == in_data)
    );

This suggests that if we create signals for the data being assigned to the buffer, it will be able to realize the assertion.

## T27
Compile. All assertions pass.