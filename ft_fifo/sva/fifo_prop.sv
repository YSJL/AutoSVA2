// This property file was autogenerated by AutoSVA on 2023-09-09
// to check the behavior of the original RTL module, whose interface is described below: 

module fifo_prop
#(
		parameter ASSERT_INPUTS = 0,
		parameter INFLIGHT_IDX = 2,
		parameter SIZE = 4
)
(		// Clock + Reset
		input  wire                          clk,
		input  wire                          rst_n,
		input  wire                          in_val,
		input  wire                          in_rdy, //output
		input  wire [SIZE-1:0]               in_data,
		
		input  wire                          out_val, //output
		input  wire                          out_rdy,
		input  wire [SIZE-1:0]               out_data //output
	);

//==============================================================================
// Local Parameters
//==============================================================================
localparam INFLIGHT = 2**INFLIGHT_IDX;

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (!rst_n);

// Re-defined wires 
wire [INFLIGHT_IDX-1:0] in_transid;
wire [INFLIGHT_IDX-1:0] out_transid;

// Symbolics and Handshake signals
wire [INFLIGHT_IDX-1:0] symb_in_transid;
am__symb_in_transid_stable: assume property($stable(symb_in_transid));
wire out_hsk = out_val && out_rdy;
wire in_hsk = in_val && in_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for fifo
if (ASSERT_INPUTS) begin
	as__fifo_fairness: assert property (out_val |-> s_eventually(out_rdy));
end else begin
	am__fifo_fairness: assume property (out_val |-> s_eventually(out_rdy));
end

// Generate sampling signals and model
reg [3:0] fifo_transid_sampled;
wire fifo_transid_set = in_hsk && in_transid == symb_in_transid;
wire fifo_transid_response = out_hsk && out_transid == symb_in_transid;

always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_sampled <= '0;
	end else if (fifo_transid_set || fifo_transid_response ) begin
		fifo_transid_sampled <= fifo_transid_sampled + fifo_transid_set - fifo_transid_response;
	end
end
co__fifo_transid_sampled: cover property (|fifo_transid_sampled);
if (ASSERT_INPUTS) begin
	as__fifo_transid_sample_no_overflow: assert property (fifo_transid_sampled != '1 || !fifo_transid_set);
end else begin
	am__fifo_transid_sample_no_overflow: assume property (fifo_transid_sampled != '1 || !fifo_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__fifo_transid_hsk_or_drop: assert property (in_val |-> s_eventually(!in_val || in_rdy));
// Assert that every request has a response and that every reponse has a request
as__fifo_transid_eventual_response: assert property (|fifo_transid_sampled |-> s_eventually(out_val && (out_transid == symb_in_transid) ));
as__fifo_transid_was_a_request: assert property (fifo_transid_response |-> fifo_transid_set || fifo_transid_sampled);


// Modeling data integrity for fifo_transid
reg [SIZE-1:0] fifo_transid_data_model;
always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_data_model <= '0;
	end else if (fifo_transid_set) begin
		fifo_transid_data_model <= in_data;
	end
end

as__fifo_transid_data_unique: assert property (|fifo_transid_sampled |-> !fifo_transid_set);
as__fifo_transid_data_integrity: assert property (|fifo_transid_sampled && fifo_transid_response |-> (out_data == fifo_transid_data_model));

assign out_transid = modul.buffer_tail_reg;
assign in_transid = modul.buffer_head_reg;

//====DESIGNER-ADDED-SVA====//



// Property File

// Check that when 'in_val' is asserted and 'in_rdy' is deasserted, no buffer space is used (no buffer is added).
as__in_no_buffer_space:
  assert property (modul.in_val && !modul.in_rdy |-> !(|modul.add_buffer));

// Check that when 'out_val' is asserted and 'out_rdy' is deasserted, no buffer space is freed (no buffer is cleared).
as__out_no_buffer_space:
  assert property (modul.out_val && !modul.out_rdy |-> !(|modul.clr_buffer));

// Check that the head of the buffer moves to the next slot only when an in handshake (in_hsk) occurs.
as__buffer_head_update:
  assert property (modul.in_hsk |=> $past(modul.buffer_head_reg + {{modul.INFLIGHT_IDX-1{1'b0}}, 1'b1}) == modul.buffer_head_reg);

// Check that the tail of the buffer moves to the next slot only when an out handshake (out_hsk) occurs.
as__buffer_tail_update:
  assert property (modul.out_hsk |=> $past(modul.buffer_tail_reg + {{modul.INFLIGHT_IDX-1{1'b0}}, 1'b1}) == modul.buffer_tail_reg);

// Ensure that if the buffer is completely full (all buffer_val_reg bits are 1), then 'in_rdy' is deasserted.
as__buffer_full_in_rdy_deassert:
  assert property (&modul.buffer_val_reg |-> !modul.in_rdy);

// Ensure that if the buffer has at least one slot free (not all buffer_val_reg bits are 1), then 'in_rdy' is asserted.
as__buffer_not_full_in_rdy_assert:
  assert property (!(&modul.buffer_val_reg) |-> modul.in_rdy);

// Ensure that if the buffer is completely empty (all buffer_val_reg bits are 0), then 'out_val' is deasserted.
as__buffer_empty_out_val_deassert:
  assert property (!(|modul.buffer_val_reg) |-> !modul.out_val);

// Ensure that if the buffer has at least one valid data (any of buffer_val_reg bits is 1), then 'out_val' is asserted.
as__buffer_not_empty_out_val_assert:
  assert property (|modul.buffer_val_reg |-> modul.out_val);

// Check that when data is added to a buffer slot (add_buffer[j] is asserted), the data in that slot matches 'in_data' in the next cycle.
generate
  for (genvar j = 0; j < modul.INFLIGHT; j = j + 1) begin : check_data_addition
    as__data_addition_to_buffer:
      assert property (modul.add_buffer[j] |=> modul.buffer_data_reg[j] == $past(modul.in_data));
  end
endgenerate

// Check that when data is read from a buffer slot (out_hsk is asserted), the read data 'out_data' matches the data in the buffer slot pointed to by buffer_tail_reg.
as__data_read_from_buffer:
  assert property (modul.out_hsk |-> modul.out_data == modul.buffer_data_reg[modul.buffer_tail_reg]);

// // Check that the number of filled buffer slots can never exceed INFLIGHT.
// as__buffer_overflow_check:
//   assert property (sum(int i = 0; i < modul.INFLIGHT; i = i + 1) modul.buffer_val_reg[i] <= modul.INFLIGHT);

// Ensure that when a buffer slot is cleared, the buffer_val_reg for that slot is set to 0 in the next cycle.
generate
  for (genvar j = 0; j < modul.INFLIGHT; j = j + 1) begin : check_buffer_clearance
    as__buffer_slot_clearance:
      assert property (modul.clr_buffer[j] |=> !modul.buffer_val_reg[j]);
  end
endgenerate





endmodule