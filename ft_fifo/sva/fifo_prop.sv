// This property file was autogenerated by AutoSVA on 2023-09-09
// to check the behavior of the original RTL module, whose interface is described below: 

module fifo_prop
#(
		parameter ASSERT_INPUTS = 0,
		parameter INFLIGHT_IDX = 2,
		parameter SIZE = 4
)
(		// Clock + Reset
		input  wire                          clk,
		input  wire                          rst_n,
		input  wire                          in_val,
		input  wire                          in_rdy, //output
		input  wire [SIZE-1:0]               in_data,
		
		input  wire                          out_val, //output
		input  wire                          out_rdy,
		input  wire [SIZE-1:0]               out_data //output
	);

//==============================================================================
// Local Parameters
//==============================================================================
localparam INFLIGHT = 2**INFLIGHT_IDX;

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (!rst_n);

// Re-defined wires 
wire [INFLIGHT_IDX-1:0] in_transid;
wire [INFLIGHT_IDX-1:0] out_transid;

// Symbolics and Handshake signals
wire [INFLIGHT_IDX-1:0] symb_in_transid;
am__symb_in_transid_stable: assume property($stable(symb_in_transid));
wire out_hsk = out_val && out_rdy;
wire in_hsk = in_val && in_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for fifo
if (ASSERT_INPUTS) begin
	as__fifo_fairness: assert property (out_val |-> s_eventually(out_rdy));
end else begin
	am__fifo_fairness: assume property (out_val |-> s_eventually(out_rdy));
end

// Generate sampling signals and model
reg [3:0] fifo_transid_sampled;
wire fifo_transid_set = in_hsk && in_transid == symb_in_transid;
wire fifo_transid_response = out_hsk && out_transid == symb_in_transid;

always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_sampled <= '0;
	end else if (fifo_transid_set || fifo_transid_response ) begin
		fifo_transid_sampled <= fifo_transid_sampled + fifo_transid_set - fifo_transid_response;
	end
end
co__fifo_transid_sampled: cover property (|fifo_transid_sampled);
if (ASSERT_INPUTS) begin
	as__fifo_transid_sample_no_overflow: assert property (fifo_transid_sampled != '1 || !fifo_transid_set);
end else begin
	am__fifo_transid_sample_no_overflow: assume property (fifo_transid_sampled != '1 || !fifo_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__fifo_transid_hsk_or_drop: assert property (in_val |-> s_eventually(!in_val || in_rdy));
// Assert that every request has a response and that every reponse has a request
as__fifo_transid_eventual_response: assert property (|fifo_transid_sampled |-> s_eventually(out_val && (out_transid == symb_in_transid) ));
as__fifo_transid_was_a_request: assert property (fifo_transid_response |-> fifo_transid_set || fifo_transid_sampled);


// Modeling data integrity for fifo_transid
reg [SIZE-1:0] fifo_transid_data_model;
always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_data_model <= '0;
	end else if (fifo_transid_set) begin
		fifo_transid_data_model <= in_data;
	end
end

as__fifo_transid_data_unique: assert property (|fifo_transid_sampled |-> !fifo_transid_set);
as__fifo_transid_data_integrity: assert property (|fifo_transid_sampled && fifo_transid_response |-> (out_data == fifo_transid_data_model));

assign out_transid = multiplier.buffer_tail_reg;
assign in_transid = multiplier.buffer_head_reg;

//====DESIGNER-ADDED-SVA====//



// Property File for the module "multiplier"

// Checks that when there's an input handshake (both in_val and in_rdy are high), 
// the head register gets incremented in the next cycle.
as__increment_head_on_input_handshake: 
    assert property (
        in_hsk |=> multiplier.buffer_head_reg == $past(multiplier.buffer_head_reg) + 1'b1
    );

// Checks that when there's an output handshake (both out_val and out_rdy are high), 
// the tail register gets incremented in the next cycle.
as__increment_tail_on_output_handshake: 
    assert property (
        out_hsk |=> multiplier.buffer_tail_reg == $past(multiplier.buffer_tail_reg) + 1'b1
    );

// Checks that when the input is ready and there's an input handshake, 
// a new value is added to the buffer in the current cycle.
as__add_to_buffer_on_input_handshake:
    assert property (
        in_hsk |-> (multiplier.add_buffer == ({{multiplier.INFLIGHT-1{1'b0}}, 1'b1} << multiplier.buffer_head_reg))
    );

// Checks that when the output is ready and there's an output handshake, 
// a value is cleared from the buffer in the current cycle.
as__clear_from_buffer_on_output_handshake:
    assert property (
        out_hsk |-> (multiplier.clr_buffer == ({{multiplier.INFLIGHT-1{1'b0}}, 1'b1} << multiplier.buffer_tail_reg))
    );

// Checks that if the output is valid, then some value in the buffer is valid.
as__output_valid_buffer_validity:
    assert property (
        multiplier.out_val |-> (|multiplier.buffer_val_reg)
    );

// Checks that if all the values in the buffer are valid, 
// then the input is not ready.
as__all_buffer_values_valid_input_not_ready:
    assert property (
        &multiplier.buffer_val_reg |-> !multiplier.in_rdy
    );

// Checks that the data being added to the buffer on an input handshake is the same 
// as the input data.
generate
    for (genvar i = 0; i < multiplier.INFLIGHT; i = i + 1) begin : data_asserts
        as__buffer_data_matches_input_data:
            assert property (
                multiplier.add_buffer[i] |-> (multiplier.buffer_data_reg[i] == in_data)
            );
    end
endgenerate

// Checks that when the buffer is full, the output data corresponds to the data 
// at the tail of the buffer.
as__full_buffer_output_data_matches_tail:
    assert property (
        &multiplier.buffer_val_reg |-> (multiplier.out_data == multiplier.buffer_data_reg[multiplier.buffer_tail_reg])
    );

// Checks that when the buffer is not full, the output data corresponds to the data 
// at the tail of the buffer.
as__not_full_buffer_output_data_matches_tail:
    assert property (
        !(&multiplier.buffer_val_reg) && (|multiplier.buffer_val_reg) |-> (multiplier.out_data == multiplier.buffer_data_reg[multiplier.buffer_tail_reg])
    );







endmodule