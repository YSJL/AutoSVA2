// This property file was autogenerated by AutoSVA on 2023-09-09
// to check the behavior of the original RTL module, whose interface is described below: 

module fifo_prop
#(
		parameter ASSERT_INPUTS = 0,
		parameter INFLIGHT_IDX = 2,
		parameter SIZE = 4
)
(		// Clock + Reset
		input  wire                          clk,
		input  wire                          rst_n,
		input  wire                          in_val,
		input  wire                          in_rdy, //output
		input  wire [SIZE-1:0]               in_data,
		
		input  wire                          out_val, //output
		input  wire                          out_rdy,
		input  wire [SIZE-1:0]               out_data //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (!rst_n);

// Re-defined wires 
wire [INFLIGHT_IDX-1:0] in_transid;
wire [INFLIGHT_IDX-1:0] out_transid;

// Symbolics and Handshake signals
wire [INFLIGHT_IDX-1:0] symb_in_transid;
am__symb_in_transid_stable: assume property($stable(symb_in_transid));
wire out_hsk = out_val && out_rdy;
wire in_hsk = in_val && in_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for fifo
if (ASSERT_INPUTS) begin
	as__fifo_fairness: assert property (out_val |-> s_eventually(out_rdy));
end else begin
	am__fifo_fairness: assume property (out_val |-> s_eventually(out_rdy));
end

// Generate sampling signals and model
reg [3:0] fifo_transid_sampled;
wire fifo_transid_set = in_hsk && in_transid == symb_in_transid;
wire fifo_transid_response = out_hsk && out_transid == symb_in_transid;

always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_sampled <= '0;
	end else if (fifo_transid_set || fifo_transid_response ) begin
		fifo_transid_sampled <= fifo_transid_sampled + fifo_transid_set - fifo_transid_response;
	end
end
co__fifo_transid_sampled: cover property (|fifo_transid_sampled);
if (ASSERT_INPUTS) begin
	as__fifo_transid_sample_no_overflow: assert property (fifo_transid_sampled != '1 || !fifo_transid_set);
end else begin
	am__fifo_transid_sample_no_overflow: assume property (fifo_transid_sampled != '1 || !fifo_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__fifo_transid_hsk_or_drop: assert property (in_val |-> s_eventually(!in_val || in_rdy));
// Assert that every request has a response and that every reponse has a request
as__fifo_transid_eventual_response: assert property (|fifo_transid_sampled |-> s_eventually(out_val && (out_transid == symb_in_transid) ));
as__fifo_transid_was_a_request: assert property (fifo_transid_response |-> fifo_transid_set || fifo_transid_sampled);


// Modeling data integrity for fifo_transid
reg [SIZE-1:0] fifo_transid_data_model;
always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_data_model <= '0;
	end else if (fifo_transid_set) begin
		fifo_transid_data_model <= in_data;
	end
end

as__fifo_transid_data_unique: assert property (|fifo_transid_sampled |-> !fifo_transid_set);
as__fifo_transid_data_integrity: assert property (|fifo_transid_sampled && fifo_transid_response |-> (out_data == fifo_transid_data_model));

assign out_transid = fifo.buffer_tail_r;
assign in_transid = fifo.buffer_head_r;

//====DESIGNER-ADDED-SVA====//

// // Ensure FIFO doesn't overfill
// assert property (@(posedge clk) disable iff (!rst_n) (in_val && !in_rdy) |-> !(buffer_head_r + 1 == buffer_tail_r));

// // Ensure FIFO doesn't underflow
// assert property (@(posedge clk) disable iff (!rst_n) (out_val && !out_rdy) |-> buffer_tail_r != buffer_head_r);

// // Ensure data integrity
// int idx = 0;
// always @(posedge clk) begin
//     if (in_val && in_rdy) begin
//         idx = buffer_head_r;
//     end
//     if (out_val && out_rdy) begin
//         assert (out_data == buffer_data_r[idx]);
//         idx = (idx + 1) % (2**INFLIGHT_IDX);
//     end
// end

// // Check handshake mechanism for input
// assert property (@(posedge clk) disable iff (!rst_n) in_val && in_rdy |-> (buffer_head_r == (buffer_head_r + 1) % (2**INFLIGHT_IDX)));

// // Check handshake mechanism for output
// assert property (@(posedge clk) disable iff (!rst_n) out_val && out_rdy |-> (buffer_tail_r == (buffer_tail_r + 1) % (2**INFLIGHT_IDX)));

    // Assert that when 'in_rdy' is low, no handshake ('in_hsk') occurs.
    // This means no write transaction occurs when FIFO is full.
    assert property (@(posedge clk) disable iff (!rst_n) !in_rdy |-> !in_hsk);

    // Assert that when 'out_val' is low, no handshake ('out_hsk') occurs.
    // This means no read transaction occurs when FIFO is empty.
    assert property (@(posedge clk) disable iff (!rst_n) !out_val |-> !out_hsk);

    // Check the circular behavior of the FIFO pointers
    // Assert that if the buffer_head_r reaches the maximum value, it wraps around.
    assert property (@(posedge clk) disable iff (!rst_n) 
                     (buffer_head_r == (INFLIGHT - 1)) && in_hsk |-> 
                     (buffer_head_r == 0));

    // Assert that if the buffer_tail_r reaches the maximum value, it wraps around.
    assert property (@(posedge clk) disable iff (!rst_n) 
                     (buffer_tail_r == (INFLIGHT - 1)) && out_hsk |-> 
                     (buffer_tail_r == 0));

    // Assert the data out is always the oldest data written into the FIFO.
    // This is a bit tricky because FIFO works in a circular manner.
    // The data is checked against the oldest data at the tail pointer.

    always @(posedge clk)
        if (out_hsk)
            fifo.out_data == fifo.buffer_data_r[fifo.buffer_tail_r];

    // Ensure that the FIFO can store up to INFLIGHT number of items and no more.
    always @(posedge clk)
        $countones(fifo.buffer_val_r) <= INFLIGHT;

endmodule